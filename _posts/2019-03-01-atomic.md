---
layout: post
title: "atomic/non atomic"
date: "2019-03-01 00:10:45 +0900"
excerpt: "atomic의 개념에 대해서 알아봅니다."
categories: Swift ObjectiveC atomic Language
tags: [Swift, ObjectiveC, atomic, Language]
image:
  feature: swiftLogo.jpg
---

`atomic` 은 ObjectiveC를 경험하였던 분들에게는 익숙한 개념이지만, Swift만 사용했던 분들에게는 익숙하지 않을 수 있는 개념입니다. `atomic`의 정의에 대해서 살펴보면 다음과 같습니다.

* atomic - 중단되지 않는

> an operation appears to occur at a single instant between its invocation and its response

`atomic`하다는 것은 프로그래밍에서 **데이터의 변경이 한 번에 일어난 것처럼 보이게 하는 것**을 의미합니다. 데이터의 값을 변경하는 작업에는 항상 값 변경의 시간이 필요합니다. ObjectiveC에서 `atomic`한 데이터를 set할 때 lock이 걸립니다.

```objective_c
if (!atomic) {
    oldValue = *slot;
    *slot = newValue;
} else {
    spin_lock_t *slotlock = &PropertyLocks[GOODHASH(slot)];
    _spin_lock(slotlock);
    oldValue = *slot;
    *slot = newValue;
    _spin_unlock(slotlock);
}
```

그래서 데이터를 변경하는 시간이 없어보이게 만듭니다.(데이터 변경시에 데이터 업데이트 이외에는 아무런 작업이 일어나지 않으므로) ObjectiveC 기준으로 property가 `atomic`하다는 것은 멀티 쓰레드 환경에서 **데이터가 반드시 변경 전, 변경 후의 상황에서만 접근되도록 하는 것을 보장**합니다.  즉, **데이터의 변경 중에는 해당 데이터에 접근이 불가능**(lock이 걸려 있으므로)합니다.

### atomic과 ObjectiveC

ObjectiveC Property는 기본적으로 `atomic`으로 선언됩니다. 다만, `atomic` property는 위에서 본 것처럼 `atomic` 데이터가 변경 도중에 접근하지 못 하도록 lock이 걸리기 때문에 property 접근의 성능이 느려집니다. 그래서 멀티 쓰레드에서 접근될 이유가 없는 많은 ObjectiveC Property(View Property 같은 것들)에는 모두 `nonatomic` 옵션이 작성되어 있습니다.

```objective_c
@interface Asset : NSObject
// name을 nonatomic으로 사용
@property (nonatomic) NSString *name;
@end
```

### atomic과 Swift

Swift는 Thread-Safe를 고려하고 디자인한 언어가 아니기 때문에 모든 property는 `non atomic`입니다. 그리고 별도로 `atomic` 옵션을 지정할 수도 없습니다. 그래서 Swift의 property가 `atomic`을 지원하기 위해서는 GCD를 통해 이를 구현해주어야 합니다. 다음 [글](https://www.objc.io/blog/2018/12/18/atomic-variables/)에서 자세한 내용을 확인할 수 있습니다. 여기에서는 위 글에서 작성된 것을 확인하는 예제만 간단히 남기도록 하겠습니다.

```swift
class AtomicValue<T> {
    let queue = DispatchQueue(label: "queue")

    private(set) var storedValue: T

    init(_ storedValue: T) {
        self.storedValue = storedValue
    }

    var value: T {
        get {
            return queue.sync {
                self.storedValue
            }
        }
        set { // read, write 접근 자체는 atomic하지만,
              // 다른 쓰레드에서 데이터 변경 도중(read, write 사이)에 접근이 가능하여, 완벽한 atomic이 아닙니다.
            queue.sync {
                self.storedValue = newValue
            }
        }
    }

    // 올바른 방법
    func mutate(_ transform: (inout T) -> ()) {
        queue.sync {
            transform(&self.storedValue)
        }
    }
}

let atomicInComplete = AtomicValue<Int>(0)
let atomicComplete = AtomicValue<Int>(0)
DispatchQueue.concurrentPerform(iterations: 100) { (idx) in

    atomicInComplete.value += idx

    atomicComplete.mutate { $0 += idx }
}

print(atomicInComplete.storedValue) // 결과: 돌릴 때마다 다름
print(atomicComplete.storedValue) // 결과: 4950
```

---

## 참고자료

- [아론 힐리가스의 Objective-C 프로그래밍](https://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788994506401)
- [Atomic vs. Non Atomic Properties Crash Course](https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c)
- [Swift Tips: Atomic Variables](https://www.objc.io/blog/2018/12/18/atomic-variables/)