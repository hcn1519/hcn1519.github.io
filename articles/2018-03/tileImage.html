<!DOCTYPE html>
<html lang="ko">

  <head>
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5VLL8HQ');</script>
  <!-- End Google Tag Manager -->
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5VL9R6T5ZN"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5VL9R6T5ZN');
  </script>

  <!-- encoding -->
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- Primary Meta Tags -->
  <title>이미지 타일링을 통한 고해상도 이미지 로딩 - hcn1519 Dev Post</title>
  <meta name="author" content="Changnam Hong">
  <meta name="title" content="이미지 타일링을 통한 고해상도 이미지 로딩 - hcn1519 Dev Post">
  <meta name="description" content="타일 이미지를 활용하여 고해상도 이미지를 랜더링하는 방법에 대해 알아봅니다.">
  <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#1d1d1d" media="(prefers-color-scheme: dark)">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="이미지 타일링을 통한 고해상도 이미지 로딩">
  <meta property="og:image" content="/public/assets/tiledimage.png">
  <meta property="og:description" content="타일 이미지를 활용하여 고해상도 이미지를 랜더링하는 방법에 대해 알아봅니다.">

  <!-- CSS -->
  <link rel="stylesheet" href="/public/sass/blogTheme.scss.css" async>
  <link rel="stylesheet" href="/public/sass/menu.scss.css" async>
  <link rel="stylesheet" href="/public/sass/syntax.scss.css" async>
  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="57x57" href="/public/favicon/apple-icon-57x57.png" async>
  <link rel="apple-touch-icon" sizes="60x60" href="/public/favicon/apple-icon-60x60.png" async>
  <link rel="apple-touch-icon" sizes="72x72" href="/public/favicon/apple-icon-72x72.png" async>
  <link rel="apple-touch-icon" sizes="76x76" href="/public/favicon/apple-icon-76x76.png" async>
  <link rel="apple-touch-icon" sizes="114x114" href="/public/favicon/apple-icon-114x114.png" async>
  <link rel="apple-touch-icon" sizes="120x120" href="/public/favicon/apple-icon-120x120.png" async>
  <link rel="apple-touch-icon" sizes="144x144" href="/public/favicon/apple-icon-144x144.png" async>
  <link rel="apple-touch-icon" sizes="152x152" href="/public/favicon/apple-icon-152x152.png" async>
  <link rel="apple-touch-icon" sizes="180x180" href="/public/favicon/apple-icon-180x180.png" async>
  <link rel="icon" type="image/png" sizes="192x192"  href="/public/favicon/android-icon-192x192.png" async>
  <link rel="icon" type="image/png" sizes="32x32" href="/public/favicon/favicon-32x32.png" async>
  <link rel="icon" type="image/png" sizes="96x96" href="/public/favicon/favicon-96x96.png" async>
  <link rel="icon" type="image/png" sizes="16x16" href="/public/favicon/favicon-16x16.png" async>
  <link rel="manifest" href="/public/favicon/manifest.json" async>
  
  <link rel="preload" href="Mona-Sans.woff2" as="font" type="/public/fonts/woff2" crossorigin>
  <link type="application/atom+xml" rel="alternate" href="https://hcn1519.github.io/feed.xml" title="hcn1519 Dev Post" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml" async>

</head>


  <body>
      <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5VLL8HQ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div class="navTop"></div>
    <div class="wrap">
      <nav class="menu">
  <div class="menu-container">
    <ul class="menu-list">
      <li class="menu-item">
        <a class="menu-link" href="/">Home</a>
      </li>
      

      
      
        
          
        
      
        
          
        
      
        
          
            <li class="menu-item">
              <a class="menu-link" href="/about">About</a>
            </li>
          
        
      
        
          
            <li class="menu-item">
              <a class="menu-link" href="/archives/">Archives</a>
            </li>
          
        
      
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
      
        
          
            <li class="menu-item">
              <a class="menu-link" href="/tags/">Tags</a>
            </li>
          
        
      
    </ul>
  </div>

  <a class="menu-toggle">
    <div class="menu-hamburger"></div>
  </a>
</nav>

      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="" title="Home">CNH</a>
            <small>Dev Post</small>
            <span style="font-size: medium;text-align: right;float: right;margin-top: 3.5px;">
              <small>
              
              <a href="/en">Read in English</a>
              
              </small>
            </span>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h2 class="post-title">이미지 타일링을 통한 고해상도 이미지 로딩</h2>
  <span class="post-date">08 Mar 2018</span>
  
  <div class="post-image-feature">
    <img class="feature-image" src=
    
    "/public/assets/tiledimage.png"
    
    alt="이미지 타일링을 통한 고해상도 이미지 로딩 feature image">

    
  </div><!-- /.image-wrap -->
  

  

  

  
  

        
  
  
  <h2 id="1-요구사항-고해상도-이미지-빠르게-보여주기">1. 요구사항: 고해상도 이미지 빠르게 보여주기</h2>

<p>정말 당연한 얘기이지만, 용량이 큰 이미지를 화면에 로딩하는 것은 시간이 오래 걸립니다. 요즘 컴퓨터가 성능이 좋아져서 큰 이미지를 빠르게 로딩하는 능력도 좋아졌지만, 그에 맞춰 사용되는 이미지도 4K, 8K, 12K로 계속해서 그 사이즈가 커지고 있어서 큰 이미지를 화면에 랜더링하는 것은 여전히 시간이 많이 걸리는 작업입니다.</p>

<p>심지어 어떤 이미지는 너무 커서 아예 화면에 로딩하는 것이 불가능합니다. 이미지를 화면에 로딩하려면 메모리 공간에 이미지를 올려야 하는데 이미지 용량이 메모리보다 커버리면 아예 로딩이 안되는 것이지요.😞 이러한 이미지의 대표적인 예로는 지도 이미지나 인공위성 이미지 같은 것들이 있습니다. 이러한 이미지는 지구 전체를 일정 수준 이상의 퀄리티로 전부 커버해야하니 몇 기가로는 어림도 없는 상황인 것입니다.</p>

<h2 id="2-이미지-타일링-기법">2. 이미지 타일링 기법</h2>

<p>이미지 타일링 기법은 이러한 거대한 이미지를 화면에 랜더링하기 위해 만들어진 기법입니다. 이미지 타일링은 이미지를 타일 형태로 조각내어 화면에 로딩하는 방식을 의미합니다.</p>

<div class="message">
  Tiles - Tiling an image segments it into a number of smaller rectangular areas called tiles.
</div>
<p>출처: <a href="http://northstar-www.dartmouth.edu/doc/idl/html_6.2/Image_Tiling.html">Working with Image Objects - Dartmouth edu</a></p>

<p>그런데 당연하게도 <code class="language-plaintext highlighter-rouge">큰 이미지 사이즈 = 타일 이미지 사이즈 * n(타일 수)</code> 라는 공식은 무시할 수 있는 오차 수준 내에서 성립합니다. 그래서 단순히 타일 형태로 이미지를 자르는 것은 의미가 없어보입니다. 하지만, 이렇게 이미지를 조각내는 것은 전체 이미지에서 필요한 부분만 로딩할 수 있게 해주고 이는 많은 장점을 가지고 있습니다.</p>

<ul>
  <li>타일 이미지는 메모리에 올릴 수 있습니다.</li>
</ul>

<p>타일 이미지는 전체 이미지를 조각낸 것이기 때문에 그 크기가 전체 이미지보다 작습니다. 그래서 디바이스의 허용 메모리에 맞게 이미지를 조각내면 타일 이미지들은 메모리보다 크기가 작으므로 화면에 표시될 수 있습니다.</p>

<ul>
  <li>거대한 이미지의 부분만 보여도 유용한 경우가 많습니다.</li>
</ul>

<p><img src="https://dl.dropbox.com/s/yqmf6e1ysigfvdv/requiredImage.png" style="max-width: 90%; margin: 0 auto;" /></p>

<p>지도 서비스를 생각해보면 이 경우를 쉽게 알 수 있습니다. 네이버 지도 앱을 켜서 이미지 로딩을 유심히 살펴보면 화면에는 전체 지도 이미지가 나오지 않습니다. 사실 애초에 그럴 필요가 없습니다. 오히려 서울 지도가 필요한 사람이 제주도 쪽을 볼 것을 우려하여 사용자가 아직 제주도 지역으로 줌을 옮기지 않았는데도 미리 제주도 지도 이미지를 다운받는 것은 굉장한 <strong>낭비</strong>입니다. 따라서 지도 앱은 사용자가 보는 부분을 중심으로 꼭 필요한 부분의 이미지만 화면에 로딩하고, 나머지 이미지는 사용자가 줌을 옮길 때, 필요에 의해 이미지가 로딩됩니다. 이렇게 전체 지도 이미지를 로딩하지 않고 부분만 로딩하는 지도 앱이 유용하다는 것은 제가 굳이 설명하지 않아도 동의할 것이라 생각합니다.</p>

<ul>
  <li>타일 이미지는 자신이 표현하는 부분에 대해서는 전체 이미지보다 우선적으로 로딩될 수 있습니다.</li>
</ul>

<p><img src="https://dl.dropbox.com/s/j8qdm0q64d00hvn/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-03-09%20%EC%98%A4%ED%9B%84%209.37.32.png" style="max-width: 70%; margin: 0 auto;" /></p>

<p>타일 이미지는 전체 이미지의 부분이기 때문에 <code class="language-plaintext highlighter-rouge">타일 이미지 용량 &lt;= 전체 이미지 용량</code>이라는 등식은 항상 성립합니다. 그래서 기본적으로 타일 이미지 로딩은 전체 이미지 로딩보다 빠릅니다. 현대의 디바이스 혹은 브라우저들은 비동기 UI 업데이트를 지원합니다. 그래서 로딩이 완료된 타일 이미지는 우선적으로 화면에 업데이트 될 수 있습니다. 이는 사용자가 이미지의 특정 부분을 빠르게 볼 수 있도록 합니다.</p>

<h2 id="3-image-pyramids">3. Image Pyramids</h2>

<p>이미지 타일링 기법만으로도 큰 이미지를 로딩할 수 있지만, 이미지 타일링만으로는 이미지 로딩속도가 충분히 빠르지 않습니다. 그래서 이를 보완하기 위해 서로 다른 <strong>scale</strong>의 이미지를 활용합니다. <strong>Image Scaling</strong>이라는 것은 이미지의 사이즈를 재조정하는 것을 의미하는데, 이 때 기본 이미지를 서로 다른 크기로 scaling한 일련의 이미지 집합을 <strong>Image Pyramids</strong>라고 합니다. 이 때, scale의 크기는 이미지의 크기와 반비례 값을 갖습니다.</p>

<p><img src="https://dl.dropbox.com/s/i7cmu15sl93bdtt/img_pyrm.gif" style="max-wid th: 100%; margin: 0 auto;" />
출처: <a href="http://northstar-www.dartmouth.edu/doc/idl/html_6.2/Image_Tiling.html">Working with Image Objects - Dartmouth edu</a></p>

<h3 id="gaussian-pyramids">Gaussian Pyramids</h3>

<p><strong>Image Pyramids</strong>도 그 종류가 여러가지인데 그 중 <strong>Gaussian Pyramids</strong>은 이미지를 스케일링하는(사이즈 축소) 것뿐만 아니라, 이미지의 일정 픽셀을 버려서 이미지를 sub sampling하는(해상도 축소) 방식으로 이미지 집합을 만든 피라미드입니다. 그래서 <strong>Gaussian Pyramids</strong> 레벨마다 이미지의 크기가 매우 빠르게 줄어드는 특징을 가지고 있습니다.</p>

<p><img src="https://dl.dropbox.com/s/i409yl3tipn0hkp/pyramid.png" style="max-width: 80%; margin: 0 auto;" />
출처: <a href="https://en.wikipedia.org/wiki/Pyramid_(image_processing)">Pyramid (image processing) - Wikipedia</a></p>

<h2 id="4-image-tiling과-gaussian-pyramids">4. Image Tiling과 Gaussian Pyramids</h2>

<p>위에서 알아본 Image Tiling과 Gaussian Pyramids를 결합하여 고해상도 이미지 로딩을 위한 타일 이미지를 생성합니다. 즉, 각각의 피라미드 레벨에 해당하는 피라미드 이미지마다 타일이미지를 생성하는 것입니다. 이런 방식으로 타일 이미지를 생성하는 것은 기존 Image Tiling이 (x,y)의 좌표값만을 파라미터로 사용한 것에서 이미지 scale 값을 새로운 파라미터로 추가한 것이라고 이해하면 됩니다. 그래서 타일을 자를 때 각각의 타일 이미지는 자신의 위치를 위한 이미지 내에서의 (x,y) 값과 더불어 scale(줌 레벨) 값을 알고 있어야 합니다.</p>

<p><img src="https://dl.dropbox.com/s/n507zqwlvc4co6h/Image_Tiling-21.jpg" style="max-width: 100%; margin: 0 auto;" />
출처: <a href="http://northstar-www.dartmouth.edu/doc/idl/html_6.2/Image_Tiling.html">Working with Image Objects - Dartmouth edu</a></p>

<p>위의 그림은 점선으로 표현된 실제 기기에서 보여지는 부분이 이미지의 scale(사용자가 줌인 한 수준)에 따라 전체 이미지의 어떤 부분을 표현하는 것인지를 보여주는 그림입니다. 여기서는 줌을 확대할 수록(level 0에 가까울 수록) 원본 이미지에 가까워지게 되고, 줌을 축소할 수록(level 2에 가까울 수록) 저화질의 이미지가 화면에 나오게 됩니다.</p>

<p><br /></p>

<h1 id="코드-구현thtiledimageview-swift">코드 구현(THTiledImageView, Swift)</h1>

<p>여기서부터는 위의 내용을 활용하여 실제로 iOS 플랫폼에서 위의 내용에 기반한 이미지뷰를 만든 방식에 대해 설명하고자 합니다. 먼저 코드는 <a href="https://github.com/TileImageTeamiOS/THTiledImageView">THTiledImageView</a>에 CocoaPod을 통해 배포되고 있습니다. 그리고 구체적인 사용 예시는 <a href="https://github.com/TileImageTeamiOS/THStorytellingView">THStorytellingView</a>에서 확인할 수 있습니다.</p>

<h2 id="들어가기-전에">들어가기 전에</h2>

<p>먼저 코드를 살펴보기 전에 코드를 수월하게 이해하기 위한 간단한 개념들을 살펴보고자 합니다. 이미 아는 내용이라면 건너뛰어도 무방합니다.</p>

<h3 id="view와-layer">View와 Layer</h3>

<p>첫 번째로 <code class="language-plaintext highlighter-rouge">View</code>와 <code class="language-plaintext highlighter-rouge">layer</code>에 대한 구분입니다. iOS에서 화면에 무엇인가를 표시하기 위해 기본적으로 <code class="language-plaintext highlighter-rouge">View</code> 클래스를 사용합니다.</p>

<h4 id="view">View</h4>

<div class="message">
  UIView - An object that manages the content for a rectangular area on the screen. Views are the fundamental building blocks of your app's user interface, and the UIView class defines the behaviors that are common to all views ...
</div>
<p>출처: <a href="https://developer.apple.com/documentation/uikit/uiview">UIKit - UIView</a></p>

<p>애플에서 설명하는 정의해서 알 수 있듯이, <code class="language-plaintext highlighter-rouge">View</code>는 화면의 사각형 반경 내의 UI를 구성할 때 쓰이는 클래스를 통칭합니다. 일반적으로 MVC 패턴을 얘기할 때 V가 이 View를 의미하는 것으로 View는 사용자와의 직접적인 커뮤니케이션(보고, 터치하고 등)을 담당합니다. 그래서 iOS에서 <code class="language-plaintext highlighter-rouge">View</code>는 크게 다음과 같은 3가지 기능을 담당한다고 말할 수 있습니다.</p>

<ol>
  <li>Drawing and animation - 먼저 <code class="language-plaintext highlighter-rouge">View</code>는 UIKit이나 Core Graphics를 통해 View 안의 콘텐츠를 그릴 수 있습니다.(THTiledImageView는 이 방식을 통해 타일 이미지를 업데이트합니다.)</li>
  <li>Layout and subview management - <code class="language-plaintext highlighter-rouge">View</code>는 <code class="language-plaintext highlighter-rouge">SubView</code>를 포함할 수 있어서 계층 구조 형태로 화면 레이아웃을 구성할 수 있도록 해줍니다.</li>
  <li>Event handling - <code class="language-plaintext highlighter-rouge">View</code>는 터치나 다른 이벤트를 사용할 수 있습니다.</li>
</ol>

<h4 id="layer">Layer</h4>

<p>앞서서 View에 대해 알아보았으니 이번에는 <code class="language-plaintext highlighter-rouge">layer</code>를 알아보겠습니다.</p>

<div class="message">
  An object that manages image-based content and allows you to perform animations on that content. Layers are often used to provide the backing store for views but can also be used without a view to display content.
</div>
<p>출처: <a href="https://developer.apple.com/documentation/quartzcore/calayer">QuartzCore - CALayer</a></p>

<p><code class="language-plaintext highlighter-rouge">layer</code>는 콘텐츠의 시각적인 부분을 담당하는 객체입니다. <code class="language-plaintext highlighter-rouge">layer</code>는 View와는 다르게 Layer는 이벤트를 관리할 수 없고, 전적으로 콘텐츠의 Drawing, Animation 을 담당합니다. 앞서서 <code class="language-plaintext highlighter-rouge">View</code>가 콘텐츠의 Drawing, Animation을 담당한다고 서술하였는데, 이는 <code class="language-plaintext highlighter-rouge">View</code> 안에 기본적으로 포함되어 있는 <code class="language-plaintext highlighter-rouge">layer</code>를 통해 이뤄지는 작업입니다. 즉, 하나의 <code class="language-plaintext highlighter-rouge">View</code>에는 기본적으로 해당 <code class="language-plaintext highlighter-rouge">View</code>의 bounds만큼을 차지하는 <code class="language-plaintext highlighter-rouge">layer</code>가 있고, 이 <code class="language-plaintext highlighter-rouge">layer</code>가 콘텐츠의 Drawing, Animation을 담당합니다. 애플은 <code class="language-plaintext highlighter-rouge">layer</code>를 다양한 화면 구성을 할 수 있도록 여러가지 <code class="language-plaintext highlighter-rouge">layer</code>를 제공합니다. 해당 <code class="language-plaintext highlighter-rouge">layer</code>들의 종류와 쓰임새는 다음  <a href="https://www.raywenderlich.com/169004/calayer-tutorial-ios-getting-started">raywenderlich - CALayer Tutorial for iOS: Getting Started</a>에서 확인할 수 있습니다.</p>

<h3 id="cgrect-cgpoint-cgsize">CGRect, CGPoint, CGSize</h3>

<p>다음으로 화면에 어떤 위치에 View가 들어가기 위해 필요한 좌표 및 View의 사이즈를 담당하는 객체를 소개하고자 합니다.</p>

<div class="message">
CGRect - A structure that contains the location and dimensions of a rectangle.
</div>
<div class="message">
CGPoint - A structure that contains a point in a two-dimensional coordinate system.
</div>
<div class="message">
CGSize - A structure that contains width and height values.
</div>

<p>View가 화면안에서 표현되기 위해서는 위치와 사이즈 값을 갖고 있어야 하는데 이를 <code class="language-plaintext highlighter-rouge">frame</code>이라고 합니다. 그리고 이 <code class="language-plaintext highlighter-rouge">frame</code>은 <code class="language-plaintext highlighter-rouge">CGRect</code> 타입으로 모든 View는 이 값을 갖고 있어야 화면에 표현될 수 있습니다.</p>

<p><img src="https://dl.dropbox.com/s/5rwfsqzsawe1e33/rect.png" style="max-width: 80%; margin: 0 auto;" /></p>

<p>iOS에서는 기본적으로 좌측 상단이 (x,y)값이 (0,0)인 좌표시스템을 갖고 있습니다. 그래서 위의 경우에서 파란색 View는 다음과 같은 <code class="language-plaintext highlighter-rouge">frame</code> 값을 지닙니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">blueView</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="kt">CGRect</span><span class="p">(</span><span class="nv">origin</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">120</span><span class="p">),</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">240</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">120</span><span class="p">))</span></code></pre></figure>

<p><br /></p>

<h2 id="image-tiling-in-thtiledimageview">Image Tiling in THTiledImageView</h2>

<p>여기서부터는 <code class="language-plaintext highlighter-rouge">THTiledImageView</code>에서 어떤 방식으로 타일 이미지를 화면에 불러내는지에 대해 코드를 통해 설명하고자 합니다. 여기서 설명하고자 하는 코드는 <a href="https://github.com/TileImageTeamiOS/THTiledImageView/blob/master/THTiledImageView/THTiledImageView/THTileImageView.swift">THTileImageView.swift</a>에 있는 코드들입니다.</p>

<h3 id="thtiledimageview의-구조">THTiledImageView의 구조</h3>

<p><code class="language-plaintext highlighter-rouge">THTiledImageView</code>는 <code class="language-plaintext highlighter-rouge">UIView</code> 클래스를 상속합니다. 그리고, View를 그리기 위한 정보는 <code class="language-plaintext highlighter-rouge">THTiledImageViewDataSource</code> 객체가 가지고 있고, <code class="language-plaintext highlighter-rouge">THTiledImageView</code>는 이를 reference 형태로 가지고 있습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">THTiledImageView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">dataSource</span><span class="p">:</span> <span class="kt">THTiledImageViewDataSource</span><span class="p">?</span>
<span class="p">}</span></code></pre></figure>

<p>그래서 <code class="language-plaintext highlighter-rouge">THTiledImageView</code> 만들 때, 생성자(init)에서 전체 이미지 사이즈(originalImageSize), 사용할 타일 이미지의 레벨 범위(minTileLevel, maxTileLevel)를 지정합니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">convenience</span> <span class="nf">init</span><span class="p">(</span><span class="nv">dataSource</span><span class="p">:</span> <span class="kt">THTiledImageViewDataSource</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="kt">CGRect</span><span class="p">(</span><span class="nv">origin</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="nv">size</span><span class="p">:</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">originalImageSize</span><span class="p">))</span>

    <span class="k">guard</span> <span class="k">let</span> <span class="nv">layer</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">layer</span> <span class="k">as?</span> <span class="kt">TiledLayer</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="k">let</span> <span class="nv">scale</span> <span class="o">=</span> <span class="kt">UIScreen</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">layer</span><span class="o">.</span><span class="n">contentsScale</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="k">let</span> <span class="nv">min</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">minTileLevel</span>
    <span class="k">let</span> <span class="nv">max</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">maxTileLevel</span>

    <span class="n">layer</span><span class="o">.</span><span class="n">levelsOfDetail</span> <span class="o">=</span> <span class="n">max</span> <span class="o">-</span> <span class="n">min</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">let</span> <span class="nv">tileSize</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">tileSize</span>
    <span class="n">layer</span><span class="o">.</span><span class="n">tileSize</span> <span class="o">=</span> <span class="n">tileSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="kt">CGRect</span><span class="p">(</span><span class="nv">origin</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="nv">size</span><span class="p">:</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">originalImageSize</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h4 id="catiledlayer">CATiledLayer</h4>

<p>애플에서는 앞서 언급한 것처럼 다양한 종류의 Layer를 제공하는데 그 중 타일 이미지를 로딩할 수 있도록 도와주는 <code class="language-plaintext highlighter-rouge">CATiledLayer</code>라는 layer를 제공합니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">open</span> <span class="kd">class</span> <span class="kt">CATiledLayer</span> <span class="p">:</span> <span class="kt">CALayer</span> <span class="p">{</span>
    <span class="kd">open</span> <span class="kd">class</span> <span class="kd">func</span> <span class="nf">fadeDuration</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">CFTimeInterval</span>
    <span class="kd">open</span> <span class="k">var</span> <span class="nv">levelsOfDetail</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="kd">open</span> <span class="k">var</span> <span class="nv">levelsOfDetailBias</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="kd">open</span> <span class="k">var</span> <span class="nv">tileSize</span><span class="p">:</span> <span class="kt">CGSize</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">CATiledLayer</code>가 제공하는 property 혹은 메소드는 위와 같습니다. <code class="language-plaintext highlighter-rouge">THTiledImageView</code>에서는 전체 View를 관리하는 layer를 <code class="language-plaintext highlighter-rouge">CATiledLayer</code>로 선언하여 MaxZoomLevel과 TileSize 같은 것들이 올바르게 작동하도록 만들었습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">THTiledImageView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="k">override</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">layerClass</span><span class="p">:</span> <span class="kt">AnyClass</span> <span class="p">{</span>
        <span class="c1">// TiledLayer는 CATiledLayer를 상속하는 클래스입니다.</span>
        <span class="k">return</span> <span class="kt">TiledLayer</span><span class="o">.</span><span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h3 id="thtiledimageview-drawing">THTiledImageView Drawing</h3>

<h4 id="drawrect">draw(rect:)</h4>

<p><code class="language-plaintext highlighter-rouge">THTiledImageView</code>는 View를 사용하는 여러가지 방법중에 <code class="language-plaintext highlighter-rouge">Drawing(draw(rect: CGRect))</code>을 사용합니다. 이것을 사용하는 이유는 <code class="language-plaintext highlighter-rouge">THTiledImageView</code>가 하나의 이미지 파일로 이뤄진 것이 아니라, 하나의 UIView 안에 여러 이미지를 layer를 업데이트하는 형태로 보여주어야 하기 때문입니다. <code class="language-plaintext highlighter-rouge">draw(rect:)</code> 함수는 최대 60hz(1초에 60번) 호출되는 함수로 업데이트 되어야 하는 <code class="language-plaintext highlighter-rouge">rect</code>를 갖고 호출됩니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">THTiledImageView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
  <span class="k">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">_</span> <span class="nv">rect</span><span class="p">:</span> <span class="kt">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 아이폰 기준으로 최대 60hz 수준으로 호출됩니다.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">draw(rect:)</code>는 시스템에서 업데이트가 필요할 때 우선적으로 호출되고 모든 화면의 업데이트가 끝나면 더이상 호출되지 않습니다. 바꿔말하면, 화면에 나타나는 부분이 모두 업데이트 되면 메소드는 종료됩니다. 그래서 만약 디바이스에서 화면을 이동하여 추가적으로 화면을 업데이트할 필요가 있는 경우에는 <code class="language-plaintext highlighter-rouge">setNeedsDisplay(rect:)</code>를 호출합니다. 이 함수를 호출하면 해당 rect에 대해서 <code class="language-plaintext highlighter-rouge">draw(rect:)</code>가 재호출됩니다.</p>

<h4 id="ctm">CTM</h4>

<p>iOS에서는 사용자가 사용하는 (x, y) 좌표값을 화면에 출력될 위치로 변환하기 위해 <code class="language-plaintext highlighter-rouge">Current Transformation Matrix(이하 CTM)</code>라는 3x3 행렬을 사용합니다.</p>

<p><img src="http://bit.ly/2Dhr7hK" align="center" border="0" alt=" \begin{bmatrix}  x' &amp; y' &amp; 1 \end{bmatrix} =  \begin{bmatrix}  x &amp; y &amp; 1 \end{bmatrix} * \begin{bmatrix}a &amp; b &amp; 0 \\c &amp; d &amp; 0 \\ t_{x}  &amp; t_{y} &amp; 1 \end{bmatrix} " width="311" height="65" /></p>

<p>위의 식에서 마지막에 있는 행렬이 CTM으로 CTM은 하나의 (x, y)를 (x’, y’)으로 변환하는 역할을 합니다. 디스플레이상에서 변환되는 두 좌표는 User Space(document page)와 Device Space(native resolution of a device) 상의 좌표입니다. <code class="language-plaintext highlighter-rouge">THTiledImageView</code>에서 CTM으로부터 얻어내야 하는 정보는 scale값입니다. 여기서 x값에 관여하는 값이 ctm 행렬의 a이고 이를 통해 화면상에서의 이미지 scale 값을 도출할 수 있습니다. 이 값을 도출하는 것은 애플의 샘플코드에 그 설명이 나와 있습니다.</p>

<div class="message">
Get the scale from the context by getting the current transform matrix, then asking for its "a" component, which is one of the two scale components. We could also ask for "d". This assumes (safely) that the view is being scaled equally in both dimensions.
</div>
<p>출처: <a href="https://developer.apple.com/library/content/samplecode/PhotoScroller/Listings/Classes_TilingView_m.html">Guide and Sample Code - TilingView.m</a></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">_</span> <span class="nv">rect</span><span class="p">:</span> <span class="kt">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ctm 사용을 위한 context 호출</span>
    <span class="k">let</span> <span class="nv">context</span> <span class="o">=</span> <span class="kt">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>

    <span class="c1">// 디바이스 scale 고려하여 zoomScale 도출</span>
    <span class="k">let</span> <span class="nv">scaleX</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">ctm</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="kt">UIScreen</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">scale</span>

    <span class="c1">// 사용자의 zoomScale 값</span>
    <span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="nf">round</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="kt">Double</span><span class="p">(</span><span class="n">scaleX</span><span class="p">)))</span>
    <span class="k">let</span> <span class="nv">level</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">maxTileLevel</span> <span class="o">+</span> <span class="kt">Int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h4 id="tile-loading">Tile Loading</h4>

<p>이렇게 이미지의 zoomLevel을 파악하고 난 후 타일 이미지를 화면에 맞게 호출합니다. 개별 타일 이미지는 사이즈 정보와 어떤 level(scale)에서, 어떤 (x,y)에 쓰이는지 정확히 알 수 있도록 <code class="language-plaintext highlighter-rouge">{imageName_imageSize_level_x_y}.jpg</code>의 형태로 이름을 갖고 있습니다. 이미지는 2차원 형태이기 때문에 전체 사각형 안에서 2중 루프를 돌면서 타일을 채워야 합니다. <code class="language-plaintext highlighter-rouge">draw(rect:)</code> 함수는 비동기로 작동하여 화면을 업데이트 하기 때문에 화면은 루프 순서대로 업데이트 되지는 않습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// 부가적인 부분은 제거한 코드입니다.</span>
<span class="k">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">_</span> <span class="nv">rect</span><span class="p">:</span> <span class="kt">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">firstColumn</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">minX</span> <span class="o">/</span> <span class="n">length</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">lastColumn</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">maxX</span> <span class="o">/</span> <span class="n">length</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">firstRow</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">minY</span> <span class="o">/</span> <span class="n">length</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">lastRow</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">maxY</span> <span class="o">/</span> <span class="n">length</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="k">in</span> <span class="n">firstRow</span><span class="o">...</span><span class="n">lastRow</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">column</span> <span class="k">in</span> <span class="n">firstColumn</span><span class="o">...</span><span class="n">lastColumn</span> <span class="p">{</span>
          <span class="k">if</span> <span class="k">let</span> <span class="nv">tile</span> <span class="o">=</span> <span class="nf">imageForTileAtColumn</span><span class="p">(</span><span class="nv">imageSize</span><span class="p">:</span> <span class="n">size</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nv">tileRect</span><span class="p">:</span> <span class="n">tileRect</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="nv">row</span><span class="p">:</span> <span class="n">row</span><span class="p">,</span> <span class="nv">level</span><span class="p">:</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">tile</span><span class="o">.</span><span class="n">tileImage</span><span class="o">.</span><span class="nf">draw</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="n">tileRect</span><span class="p">)</span>
          <span class="p">}</span>      
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="nf">imageForTileAtColumn</span><span class="p">(</span><span class="nv">imageSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">,</span> <span class="nv">tileRect</span><span class="p">:</span> <span class="kt">CGRect</span><span class="p">,</span> <span class="n">_</span> <span class="nv">column</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">row</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">THTile</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

    <span class="k">let</span> <span class="nv">sizeInt</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">imageSize</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
    <span class="c1">// 타일 이미지 Key 값</span>
    <span class="k">let</span> <span class="nv">imageKey</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">thumbnailImageName</span> <span class="o">+</span> <span class="s">"_</span><span class="se">\(</span><span class="n">sizeInt</span><span class="se">)</span><span class="s">_</span><span class="se">\(</span><span class="n">level</span><span class="se">)</span><span class="s">_</span><span class="se">\(</span><span class="n">column</span><span class="se">)</span><span class="s">_</span><span class="se">\(</span><span class="n">row</span><span class="se">)</span><span class="s">.</span><span class="se">\(</span><span class="n">dataSource</span><span class="o">.</span><span class="n">imageExtension</span><span class="se">)</span><span class="s">"</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">THImageCacheManager</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">retrieveTiles</span><span class="p">(</span><span class="nv">key</span><span class="p">:</span> <span class="n">imageKey</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">THTile</span><span class="p">(</span><span class="nv">tileImage</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span> <span class="nv">tileRect</span><span class="p">:</span> <span class="n">tileRect</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>타일 이미지를 서버로부터 다운로드 받아서 처리하는 것은 downloadAndRedrawImages 함수에서 수행됩니다. 가장 먼저 이미지가 캐싱되어 있는지 확인하고, 이미지 다운로드가 진행됩니다. 그리고 그 이후는 타일마다 이미지 다운로드 -&gt; 캐싱 -&gt; setNeedsDisplay(rect:) 호출 -&gt; draw(rect:) -&gt; 다운로드된 이미지 업데이트 순서로 수행됩니다.</p>
</blockquote>

<hr />

<h2 id="참고자료">참고자료</h2>
<ul>
  <li><a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Displays/Displays.html">Display in iOS</a></li>
  <li><a href="http://northstar-www.dartmouth.edu/doc/idl/html_6.2/Image_Tiling.html">Working with Image Objects - Dartmouth edu</a></li>
  <li><a href="http://darkpgmr.tistory.com/137">Scale Space와 이미지 피라미드(image pyramid)</a></li>
  <li><a href="https://developer.apple.com/documentation/uikit/uiview">UIKit - UIView</a></li>
  <li><a href="https://developer.apple.com/documentation/quartzcore/calayer">QuartzCore - CALayer</a></li>
</ul>


<div class="related">
  
  
  
  
  
  

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  
  </ul>

  
    
    <h2>최근 글</h2>
    
    <ul class="related-posts">
      
        <li>
          <h3>
            <a href="/articles/2022-05/diffabledatasource">
              DiffableDataSource로 안전하게 UIKit List 업데이트하기
              <small>13 May 2022</small>
            </a>
          </h3>
        </li>
      
        <li>
          <h3>
            <a href="/articles/2022-04/swift_async_await">
              Swift Async Await
              <small>08 Apr 2022</small>
            </a>
          </h3>
        </li>
      
        <li>
          <h3>
            <a href="/articles/2022-01/test_spy">
              Test Spy
              <small>05 Jan 2022</small>
            </a>
          </h3>
        </li>
      
    </ul>
  
</div>


<script>
  
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    // dark mode
    
  }
</script>
<script src="https://utteranc.es/client.js"
        repo="hcn1519/hcn1519.github.io"
        issue-term="og:title"
        label="gets Comments 🙌"
        theme=github-dark
        crossorigin="anonymous"
        async>
</script>

<div class="back-home">
    <a href="">< Home</a>
  </div>
</div>
      </div>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/public/js/sidebarHamburger.js"></script>
  </body>
</html>
